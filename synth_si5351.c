/******************************************************************************
 *
 * synth_si4351.c - Driver for the Silicon Labs si5351 Frequency synthesizer
 *  Interfaces the TI tiva C Launchpad with the Silicon Labs si5351 frequency
 *  synthesizer
 *
 *  \note Used to generate the ADC CLK on the GTBE-TM4C1294XL
 *
 *	\note Predefined register settings are defined in synth_si4351_reg_map.h
 *
 *  Author: Curtis Mayberry
 *  Georgia Tech IMEMS
 *  rev1 May 2014
 *
 *  Originally written for the MRIG gyroscope project
 *
 *  This work is licensed under the Creative Commons Attribution-ShareAlike 3.0
 *  Unported License. To view a copy of this license, visit
 *  http://creativecommons.org/licenses/by-sa/3.0/ or send a letter to Creative
 *  Commons, 444 Castro Street, Suite 900, Mountain View, California, 94041, USA.
 *
 ******************************************************************************/

#include <stdbool.h>
#include <stdint.h>
#include "inc/hw_memmap.h"

// Tivaware
#include "driverlib/rom.h"
#include "driverlib/rom_map.h"
#include "driverlib/i2c.h"
#include "driverlib/sysctl.h"
#include "driverlib/gpio.h"
#include "driverlib/pin_map.h"
#include "driverlib/debug.h"
#include "driverlib/flash.h"

// GTBE Lib
#include "synth_si5351.h"
#include "tw_extension.h"

static uint8_t PowerDownOutputDriversRegValues[8] = {0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80};

/****************************
 * Initialization Functions *
 ****************************/

/**
 * Initializes the synthesizer
 * \parameter synthEN enables or disables the synthesizer outputs
 **/
void synth_init(bool synthEN, uint8_t xtal_cl, uint8_t* regConfig, uint8_t outputEn) {
	synth_setXTALcapacitance(xtal_cl);
	if(synthEN) {
		synth_initADCreclkENL(false);
		synth_initConfig(regConfig, outputEn);
	}
	else {
		// Disable synth
		synth_initADCreclkENL(true);
		synth_outputDisableAll();
		synth_powerDownOutputDrivers();
	}
}

/**
 * Loads a configuration to the synth
 *
 * \param regConfig - Predefined register configuration array
 *  Choose a config array from synth_si5351_configs.h
 *
 * \note The configuration is generated by ClockBuilder Desktop
 *
 * \note Configuration
 **/
void synth_initConfig(uint8_t* regConfig, uint8_t outputEn) {
	// Disable Outputs
	synth_outputDisableAll();
	// Powerdown all output drivers
	synth_powerDownOutputDrivers();
	// Set interrupt masks (Mask all interrupts)
	synth_setInterruptMasks(SYNTH_INT_STATUS_MASK_SYS_INIT_MASK |
							SYNTH_INT_STATUS_MASK_LOL_B_MASK |
							SYNTH_INT_STATUS_MASK_LOL_A_MASK |
							SYNTH_INT_STATUS_MASK_LOS_MASK);
	synth_writeRegConfig(regConfig);
	// Apply PLLA and PLLB soft reset
	synth_PLLreset(SYNTH_RST_PLL_PLLB_RST | SYNTH_RST_PLL_PLLA_RST);
	// Enable desired outputs (enables CLK0)
	synth_outputEnable(outputEn);
}

/**
 * Initializes ~ADC_RECLK_ENL to enable (false) or disable (true) the reclking of the
 * ADC output to the synthesizer clock.
 * \parameter bEnable Active low enable signal for the D flip-flop that reclocks the
 * ADC input when using the synthesizer to clock the ADC.
 **/
  void synth_initADCreclkENL(bool bEnable) {
	 MAP_SysCtlPeripheralEnable(SYNTH_ADC_RECLK_ENL_GPIO_PERIPH);
	 MAP_GPIOPinTypeGPIOOutput(SYNTH_ADC_RECLK_ENL_GPIO_BASE, SYNTH_ADC_RECLK_ENL_PIN);
	 if(bEnable) {
		 MAP_GPIOPinWrite(SYNTH_ADC_RECLK_ENL_GPIO_BASE, SYNTH_ADC_RECLK_ENL_PIN, 0);
	 }
	 else {
		 MAP_GPIOPinWrite(SYNTH_ADC_RECLK_ENL_GPIO_BASE, SYNTH_ADC_RECLK_ENL_PIN, SYNTH_ADC_RECLK_ENL_PIN);
	 }
  }

/*********************
 * Command Functions *
 *********************/

/**
 * Disables all clock outputs
 **/
void synth_outputDisableAll(void) {
	synth_writeRegI2C(SYNTH_OUT_EN_CTL_REG, SYNTH_REG_VAL_OUTPUT_DISABLE);
}

/**
 * Enables the selected synthesizer outputs
 * \param outputEn - clock outputs to be enabled.
 * Those not included will be disabled
 * Logical or of one or more of the following values:
 * SYNTH_OUT_EN_CTL_CLK7_OEB
 * SYNTH_OUT_EN_CTL_CLK6_OEB
 * SYNTH_OUT_EN_CTL_CLK5_OEB
 * SYNTH_OUT_EN_CTL_CLK4_OEB
 * SYNTH_OUT_EN_CTL_CLK3_OEB
 * SYNTH_OUT_EN_CTL_CLK2_OEB
 * SYNTH_OUT_EN_CTL_CLK1_OEB
 * SYNTH_OUT_EN_CTL_CLK0_OEB
 *
 * \note Si5351A (10-Pin MSOP) only has CLK 0-2
 **/
void synth_outputEnable(uint8_t outputEn) {
	synth_writeRegI2C(SYNTH_OUT_EN_CTL_REG, ~outputEn);
}

/**
 * Powers down all output drivers
 **/
void synth_powerDownOutputDrivers(void) {
	synth_writeConsecutiveRegsI2C(16, 8, PowerDownOutputDriversRegValues);
}

/**
 * Sets interrupt masks
 *
 * \param interruptMask - Indicates the interrupts that are to be masked
 * Logical or of one or more of the following values:
 *  SYNTH_INT_STATUS_MASK_SYS_INIT_MASK
 *  SYNTH_INT_STATUS_MASK_LOL_B_MASK
 *  SYNTH_INT_STATUS_MASK_LOL_A_MASK
 *  SYNTH_INT_STATUS_MASK_LOS_MASK
 *
 *  \note When an interrupt is masked it prevents the associated pin from
 *  going low when the interrupt is asserted
 **/
void synth_setInterruptMasks(uint8_t interruptMasks) {
	synth_writeRegI2C(SYNTH_INT_STATUS_MASK_REG, interruptMasks);
}

/**
 * Reads the interrupt status register
 *
 * \return interrupt status
 *
 * \note Each interrupt is sticky and will remain high until it is cleared
 **/
uint32_t synth_readINTstatus(void) {
	return synth_readRegI2C(SYNTH_INT_STATUS_REG);
}

/**
 * Clears the selected interrupts in the interrupt status register
 *
 * \param interruptCLR - interrupts to be cleared
 *  Logical or of one or more of the following values:
 *  SYNTH_INT_STATUS_SYS_INIT_STKY
 *  SYNTH_INT_STATUS_LOL_B_STKY
 *  SYNTH_INT_STATUS_LOL_A_STKY
 *  SYNTH_INT_STATUS_LOS_STKY
 *
 * \note Each interrupt is sticky and will remain high until it is cleared
 **/
void synth_clearINT(uint8_t interruptCLR) {
	synth_writeRegI2C(SYNTH_INT_STATUS_REG, ~interruptCLR);
}

/**
 * Writes the device configuration from the register map generated by
 *  ClockBuilder Desktop
 *
 * \param regConfig - configuration array of each register value
 **/
void synth_writeRegConfig(uint8_t* regConfig) {
	// write registers 15 - 92
	synth_writeConsecutiveRegsI2C(15, 78, &regConfig[0]);
	// write registers 149 - 170
	synth_writeConsecutiveRegsI2C(149, 22, &regConfig[78]);
	// write register  180
	synth_writeRegI2C(180, regConfig[100]);
}

/**
 * Resets the selected PLL
 *
 * \param PLLrst - The PLL(s) to be reset
 *  Logical or of one or more of the following values:
 *  SYNTH_RST_PLL_PLLB_RST
 *  SYNTH_RST_PLL_PLLA_RST
 **/
void synth_PLLreset(uint8_t PLLrst) {
	synth_writeRegI2C(SYNTH_RST_PLL_REG, PLLrst);
}

/**
 * Reads the device status register
 *
 * \return device status (reg 0)
 **/
uint32_t synth_readDeviceStatus(void) {
	return synth_readRegI2C(SYNTH_STATUS_REG);
}

/**
 * Sets the internal load capacitance of the crystal
 *
 * \param xtal_cl - internal crystal load capacitance
 * Adds the selected capacitance in parallel with both XTAL inputs
 *  Select one of the following values:
 *  SYNTH_XTAL_CL_6PF
 *  SYNTH_XTAL_CL_8PF
 *  SYNTH_XTAL_CL_10PF
 **/
void synth_setXTALcapacitance(uint8_t xtal_cl) {
	synth_writeRegI2C(SYNTH_RST_PLL_REG, xtal_cl);
}

/**
 * Selects which fanouts to enable
 *
 * \param fanoutEN selects which fanouts are enabled
 *  Logical or of one or more of the following values:
 *  SYNTH_FANOUT_EN_CLKIN
 *  SYNTH_FANOUT_EN_XO
 *  SYNTH_FANOUT_EN_MS
 **/
void synth_fanoutEnable(uint8_t fanoutEN) {
	synth_writeRegI2C(SYNTH_FANOUT_EN_REG, fanoutEN);
}

/*****************
 * I2C Functions *
 *****************/

/**
 * Initializes the synthesizer I2C serial interface in normal mode
 *
 * \param fast - true sets the I2C interface to fast (400kbps) mode
 *  false sets the I2C interface to normal (100kbps) mode
 **/
void synth_initI2C(bool fast) {
	// Enable Peripherals
	MAP_SysCtlPeripheralEnable(SYNTH_I2C_PERIPH);
	MAP_SysCtlPeripheralEnable(SYNTH_GPIO_PERIPH);
	// Set the pin muxing for I2C peripheral
	MAP_GPIOPinConfigure(SYNTH_I2C_SCL_PIN_CONFIG);
	MAP_GPIOPinConfigure(SYNTH_I2C_SDA_PIN_CONFIG);

	MAP_GPIOPinTypeI2CSCL(SYNTH_GPIO_BASE, SYNTH_SCL_PIN);
	MAP_GPIOPinTypeI2C(SYNTH_GPIO_BASE, SYNTH_SDA_PIN);

	I2CMasterInitExpClk(SYNTH_I2C_BASE, SysCtlClockGet(), fast); // true = 400kbps, false = 100kbps
	I2CMasterSlaveAddrSet(SYNTH_I2C_BASE, SYNTH_I2C_SLAVE_ADDRESS, false);
}

/**
 * Writes to a single register
 *
 * \param regNum - Register number to be written.
 * \param regValue - The register value that is to be written
 **/
void synth_writeRegI2C(uint8_t regNum, uint8_t regValue) {
	// Write register number
	while(I2CMasterBusy(SYNTH_I2C_BASE)) {} // Wait until the I2C line is not busy
	I2CMasterSlaveAddrSet(SYNTH_I2C_BASE, SYNTH_I2C_SLAVE_ADDRESS, false);
	I2CMasterDataPut(SYNTH_I2C_BASE, regNum);
	I2CMasterControl(SYNTH_I2C_BASE, I2C_MASTER_CMD_BURST_SEND_START);
	twe_I2CMasterVerify(SYNTH_I2C_BASE, true ,false);
	// Write register value
	I2CMasterDataPut(SYNTH_I2C_BASE, regValue);
	I2CMasterControl(SYNTH_I2C_BASE, I2C_MASTER_CMD_BURST_SEND_FINISH);
	twe_I2CMasterVerify(SYNTH_I2C_BASE, true ,false);
}

/**
 * Writes to consecutive registers
 * e.g. writes to register number 1,2,3,...
 *
 * \param regNumStart - Register number of the first register to be written.
 * \param regCNT - The number of registers to write. Must have regCNT > 1
 * \param regValues - The register values that are to be written
 **/
void synth_writeConsecutiveRegsI2C(uint8_t regNumStart, uint8_t regCNT, uint8_t* regValues) {
	ASSERT(regCNT > 1);

	// Write first register number
	while(I2CMasterBusy(SYNTH_I2C_BASE)) {} // Wait until the I2C line is not busy
	I2CMasterSlaveAddrSet(SYNTH_I2C_BASE, SYNTH_I2C_SLAVE_ADDRESS, false);
	I2CMasterDataPut(SYNTH_I2C_BASE, regNumStart);
	I2CMasterControl(SYNTH_I2C_BASE, I2C_MASTER_CMD_BURST_SEND_START);
	twe_I2CMasterVerify(SYNTH_I2C_BASE, true ,false);

	// Write each register except the last
	uint32_t i = 0;
	while(i < regCNT-1) {
		I2CMasterDataPut(SYNTH_I2C_BASE, regValues[i]);
		I2CMasterControl(SYNTH_I2C_BASE, I2C_MASTER_CMD_BURST_SEND_CONT);
		twe_I2CMasterVerify(SYNTH_I2C_BASE, true ,false);
		i++;
	}

	// Write last register
	I2CMasterDataPut(SYNTH_I2C_BASE, regValues[i]);
	I2CMasterControl(SYNTH_I2C_BASE, I2C_MASTER_CMD_BURST_SEND_FINISH);
	twe_I2CMasterVerify(SYNTH_I2C_BASE, true ,false);
}

/**
 * Reads from a single register
 *
 * \param regNum - Register number to be read.
 *
 * \return Register value read
 **/
uint32_t synth_readRegI2C(uint8_t regNum) {
	while(I2CMasterBusy(SYNTH_I2C_BASE)) {} // Wait until the I2C line is not busy
	// Write register number
	I2CMasterSlaveAddrSet(SYNTH_I2C_BASE, SYNTH_I2C_SLAVE_ADDRESS, false);
	I2CMasterDataPut(SYNTH_I2C_BASE, regNum);
	I2CMasterControl(SYNTH_I2C_BASE, I2C_MASTER_CMD_SINGLE_SEND);
	twe_I2CMasterVerify(SYNTH_I2C_BASE, false ,false);
	// Read register value
	I2CMasterSlaveAddrSet(SYNTH_I2C_BASE, SYNTH_I2C_SLAVE_ADDRESS, true);
	I2CMasterControl(SYNTH_I2C_BASE, I2C_MASTER_CMD_SINGLE_RECEIVE);
	twe_I2CMasterVerify(SYNTH_I2C_BASE, false ,true);
	return I2CMasterDataGet(SYNTH_I2C_BASE);
}
